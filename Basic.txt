============ Literals =============
Literal is a fixed value that has been inserted directly into the source code.
eg - int a = 23; std::string s = "Hello"; Here Hello and 23 are literals


============ Header Guards ==========
Used to prevent including same header file twice which can cause CTE
#ifndef ___UNIQUE_NAME___
#define ___UNIQUE_NAME___
...
#endif // ___UNIQUE_NAME___

Another way is by using
#pragma ones


============ Pre-processors ============
Expanded/Evaluated during pre-processing step.

#define
The defined quantity remains from the point it is declared till the end of file since pre-processor does not know anything about C++ concepts.

1) Object like macros with and without substitution text
  #define PARA
  #define PARA 12
2) Function like macros
  #define PRINT(x,y) ( std::cout << x << " " << y << std::endl )
  #define MIN(i,j) ( i < j ? i :j )
  #define PNT(k) ( (std::cout << k << std::endl), (std::cout << k+2 << std::endl))
  #define KK(x,y) ( std::cout << MIN(x, y) << std::endl )

#if, #endif, #ifdef, #ifndef, #elif, #else

#if 0, #if 1  // To prevent part of the code from compiling and not compiling

#pragma
This directive is a special purpose directive and is used to turn on or off some features. This type of directives are compiler-specific 
i.e., they vary from compiler to compiler.
#pragma startup foo1  // function needs to be called before main
#pragma exit foo2     // function needs to be called after main
#pragma ones          // include header file only ones like header guard


============ Increment/Decrement ============
Pre increment is faster than post. Can be seen from the assembly code.
Decrementing loop might be faster since comparing to 0 is faster than comparing to non-zero number.


============ Switch ============
In case break statement is not used, the code will execture the next case body.
case 0:
case 1:
  <statement_1>;
case 2:
  <statement_2>;
In case of 0 or 1, both statement_1 and statement_2 are executed.

Should not initialize variables inside the switch because the initialization step might get skipped. Causes CTE.


============ Const Pointers ============
int a = 12, b = 13;
const int* ptr = &a;
ptr = &b;             // Legal
*ptr = 44;            // Illegal

int* const ptr = &a;
ptr = &b;             // Illegal
*ptr = 44;            // Legal

const int* const ptr = &a;
// Both ptr = &b and *ptr = 44 are illegal


============ Reference ============
Cannot return reference to local variable from a function.


============ Program termination =============
std::abort() - Abnormal termination without cleanup
std::exit( EXIT_FAILURE ) - Normal termination with cleanup
std::quick_exit( EXIT_SUCCESS ) - Normal termination without complete cleanup
std::_Exit( EXIT_SUCCESS ) - Normal termination without cleanup
std::atexit( <function_name> ) - Register function to be called when exit is called. In case of multiple function, order of calling is reverse of adding them.
std::at_quick_exit( <function_name> ) - Register function to be called when std::quick_exit() is called.
